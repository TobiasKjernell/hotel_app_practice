React Query 
------------

powerful lib for managing remote (server) states.

data is cached (stored), which means if component A is fetching 'cars' 
react Query will store it and if component b is fetching 'cars' later, it will
take the stored info from react query instead of fetching from server.
In this case, component b will get a instant feedback on information.

automatic error and loading states

automatic re-fetching to keep state synched

pre-fetching (ex: 2 different pages, we have info for the 'other' page already)

offline support

Example call:
const x = useQuery({
    queryKey: ['cabin'],
    queryFn: getCabins
  })

  queryKey: identifies it's specific query.
  So if you example going to delete a item from database, you will have to
  'mutate' it and make sure it updates on client aswell.
  By so:   const { isPending, mutate } = useMutation({
    mutationFn: (id) => deleteCabin(id),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ['cabins']
      });  
    },
    onError: err => alert(err.message)
  })

  By getting the current queryClient( useQueryClient hook ) you can use
  quertClient.invalidateQueries(). You use this one to mutate etc delete/update
  and also to tell it to refetch.


  ---- TOASTS 
  Pop-up notifications
  npm i react-hot-toast

  ---- React Forms
  npm i react-hook-form
  const { register, handleSubmit} = useForm();
Usages---
  1.<Input type="number" id="discount" defaultValue={0} {...register('discount')} />
  2. <Form onSubmit={handleSubmit(handleOnSubmit, onError)}>
  second paramter in handleSubmit is a error callback.  

   const handleOnSubmit = (data) => {
    //put your code in here. data = form input info.
    //data is the return of all form inputs in a object.
  }

PATTERNS
Render Prop Pattern:
A render prop is a prop that is a function.
A component with a render prop receives a function as a prop and calls that function to determine what to render. 

Inversion of Control - 
When a component needs to allow a parent component to control its rendering logic or complex behavior, a render prop can be used to delegate that control. 

HOC: 
Higher-order components (HOC) are an advanced technique in React that is used for reusing component logic. It is the function that takes the original component and returns the new enhanced component. 

Compound Component Pattern:

import { useState, createContext, useContext } from "react";

//1.create context
const CounterContext = createContext();

//2.parent component
function Counter({ children }) {
  const [count, setCount] = useState(0);
  const increase = () => setCount((c) => c + 1);
  const decrease = () => setCount((c) => c - 1);

  return (
    <CounterContext.Provider value={{ count, increase, decrease }}>
      <span>{children}</span>
    </CounterContext.Provider>
  );
}

//3.child components
const Count = () => {
  const { count } = useContext(CounterContext);
  return <span>{count}</span>;
};

const Label = ({ children }) => {
  return <span>{children}</span>;
};

const Increase = ({ icon }) => {
  const { increase } = useContext(CounterContext);
  return <button onClick={increase}>{icon}</button>;
};

const Decrease = ({ icon }) => {
  const { decrease } = useContext(CounterContext);
  return <button onClick={decrease}>{icon}</button>;
};
//4.add child components as prop into parent component
Counter.Count = Count;
Counter.Label = Label;
Counter.Increase = Increase;
Counter.Decrease = Decrease;

export default Counter;

USAGE:
   <Counter>
        <Counter.Label>Counter</Counter.Label>
        <Counter.Decrease icon="-" />
        <Counter.Count />
        <Counter.Increase icon="+" />
      </Counter>